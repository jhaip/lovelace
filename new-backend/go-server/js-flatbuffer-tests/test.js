var flatbuffers = require('./flatbuffers').flatbuffers;
var roomupdatefbs = require('./request_generated').roomupdatefbs; // Generated by `flatc`.

function stringToUint(string) {
    var string = unescape(encodeURIComponent(string)),
        charList = string.split(''),
        uintArray = [];
    for (var i = 0; i < charList.length; i++) {
        uintArray.push(charList[i].charCodeAt(0));
    }
    return new Uint8Array(uintArray);
}

function uintToString(uintArray) {
    var encodedString = String.fromCharCode.apply(null, uintArray),
        decodedString = decodeURIComponent(escape(encodedString));
    return decodedString;
}

function testRoomUpdateSerialization() {
    var builder = new flatbuffers.Builder(1024);

    var factValue = roomupdatefbs.Fact.createValueVector(builder, stringToUint("Hello World!"))

    roomupdatefbs.Fact.startFact(builder)
    roomupdatefbs.Fact.addType(builder, roomupdatefbs.FactType.Text)
    roomupdatefbs.Fact.addValue(builder, factValue)
    var fact = roomupdatefbs.Fact.endFact(builder)

    var updateSource = builder.createString("1234")
    var updateSubId = builder.createString("asdf")
    var facts = roomupdatefbs.RoomUpdate.createFactsVector(builder, [fact])

    roomupdatefbs.RoomUpdate.startRoomUpdate(builder)
    roomupdatefbs.RoomUpdate.addType(builder, roomupdatefbs.UpdateType.Claim)
    roomupdatefbs.RoomUpdate.addSource(builder, updateSource)
    roomupdatefbs.RoomUpdate.addSubscriptionId(builder, updateSubId)
    roomupdatefbs.RoomUpdate.addFacts(builder, facts)
    var update = roomupdatefbs.RoomUpdate.endRoomUpdate(builder)

    var updates = roomupdatefbs.RoomUpdates.createUpdatesVector(builder, [update])

    roomupdatefbs.RoomUpdates.startRoomUpdates(builder)
    roomupdatefbs.RoomUpdates.addUpdates(builder, updates)
    var full_updates_msg = roomupdatefbs.RoomUpdates.endRoomUpdates(builder)

    builder.finish(full_updates_msg)
    var msg_buf = builder.asUint8Array(); // Of type `Uint8Array`.
    return Buffer.from(msg_buf)
}

function makeSubscriptionMessage(source, subscriptionId, subscriptionQueryParts) {
    var builder = new flatbuffers.Builder(1024);

    var subscriptionFactArray = new Array(subscriptionQueryParts.length);
    for (let i = 0; i < subscriptionQueryParts.length; i+=1) {
        var factValue = roomupdatefbs.Fact.createValueVector(
            builder,
            stringToUint(subscriptionQueryParts[i])
        )
        roomupdatefbs.Fact.startFact(builder)
        roomupdatefbs.Fact.addType(builder, roomupdatefbs.FactType.Text)
        roomupdatefbs.Fact.addValue(builder, factValue)
        subscriptionFactArray[i] = roomupdatefbs.Fact.endFact(builder)
    }    
    var facts = roomupdatefbs.RoomUpdate.createFactsVector(builder, subscriptionFactArray)

    var updateSource = builder.createString(source)
    var updateSubId = builder.createString(subscriptionId)

    roomupdatefbs.RoomUpdate.startRoomUpdate(builder)
    roomupdatefbs.RoomUpdate.addType(builder, roomupdatefbs.UpdateType.Subscribe)
    roomupdatefbs.RoomUpdate.addSource(builder, updateSource)
    roomupdatefbs.RoomUpdate.addSubscriptionId(builder, updateSubId)
    roomupdatefbs.RoomUpdate.addFacts(builder, facts)
    var update = roomupdatefbs.RoomUpdate.endRoomUpdate(builder)

    // Subscription only has 1 RoomUpdate
    var updates = roomupdatefbs.RoomUpdates.createUpdatesVector(builder, [update])
    roomupdatefbs.RoomUpdates.startRoomUpdates(builder)
    roomupdatefbs.RoomUpdates.addUpdates(builder, updates)
    var full_updates_msg = roomupdatefbs.RoomUpdates.endRoomUpdates(builder)

    builder.finish(full_updates_msg)
    var msg_buf = builder.asUint8Array(); // Of type `Uint8Array`.
    return Buffer.from(msg_buf)
}


function makeBatchMessage(source, batched_calls) {
    var builder = new flatbuffers.Builder(1024);
    const batchMessageTypeToMessageTypeEnum = {
        "claim": roomupdatefbs.UpdateType.Claim,
        "retract": roomupdatefbs.UpdateType.Retract,
        "death": roomupdatefbs.UpdateType.Death
    }
    const factTypeStringToTypeEnum = {
        "id": roomupdatefbs.FactType.Id,
        "text": roomupdatefbs.FactType.Text,
        "integer": roomupdatefbs.FactType.Integer,
        "float": roomupdatefbs.FactType.Float,
        "binary": roomupdatefbs.FactType.Binary
    }

    var batchedUpdatesArray = new Array(batched_calls.length);
    for (let i = 0; i < batched_calls.length; i += 1) {
        var factArray = new Array(batched_calls[i].fact.length);
        for (let k = 0; k < factArray.length; k += 1) {
            let factPart = batched_calls[i].fact[k];
            var factValue = roomupdatefbs.Fact.createValueVector(
                builder,
                stringToUint(factPart[1])
            )
            var factType = factTypeStringToTypeEnum[factPart[0]];
            
            roomupdatefbs.Fact.startFact(builder)
            roomupdatefbs.Fact.addType(builder, factType)
            roomupdatefbs.Fact.addValue(builder, factValue)
            factArray[k] = roomupdatefbs.Fact.endFact(builder)
        }
        var facts = roomupdatefbs.RoomUpdate.createFactsVector(builder, factArray)

        var updateType = batchMessageTypeToMessageTypeEnum[batched_calls[i].type];
        var updateSource = builder.createString(source)
        var updateSubId = builder.createString("") // batch calls don't have subscription IDs

        roomupdatefbs.RoomUpdate.startRoomUpdate(builder)
        roomupdatefbs.RoomUpdate.addType(builder, updateType)
        roomupdatefbs.RoomUpdate.addSource(builder, updateSource)
        roomupdatefbs.RoomUpdate.addSubscriptionId(builder, updateSubId)
        roomupdatefbs.RoomUpdate.addFacts(builder, facts)
        batchedUpdatesArray[i] = roomupdatefbs.RoomUpdate.endRoomUpdate(builder)
    }

    // Subscription only has 1 RoomUpdate
    var updates = roomupdatefbs.RoomUpdates.createUpdatesVector(builder, [update])
    roomupdatefbs.RoomUpdates.startRoomUpdates(builder)
    roomupdatefbs.RoomUpdates.addUpdates(builder, batchedUpdatesArray)
    var full_updates_msg = roomupdatefbs.RoomUpdates.endRoomUpdates(builder)

    builder.finish(full_updates_msg)
    var msg_buf = builder.asUint8Array(); // Of type `Uint8Array`.
    return Buffer.from(msg_buf)
}

function testRoomUpdateDeserialization(data) {
    var buf = new flatbuffers.ByteBuffer(data);
    var room_updates_obj = roomupdatefbs.RoomUpdates.getRootAsRoomUpdates(buf)
    var updates_length = room_updates_obj.updatesLength()
    console.log(updates_length)
    update = room_updates_obj.updates(0)
    console.log(update.type())
    var source = update.source()
    var sub_id = update.subscriptionId()
    console.log(source)
    console.log(sub_id)
    facts_length = update.factsLength()
    console.log(facts_length)
    fact = update.facts(0)
    console.log(fact.type())
    console.log(fact.valueArray())
    console.log(uintToString(fact.valueArray()))
}

var sRaw = testRoomUpdateSerialization()
var s = new Uint8Array(sRaw)
// console.log(s)
console.log(s.join(' '))
console.log(s.length)
testRoomUpdateDeserialization(s)

console.log("--------------")

function testRoomUpdateSerializationResult() {
    var builder = new flatbuffers.Builder(1024);

    var resultVariableName = builder.createString("X")
    var resultValue = roomupdatefbs.RoomResult.createValueVector(builder, stringToUint("blue"))

    roomupdatefbs.RoomResult.startRoomResult(builder)
    roomupdatefbs.RoomResult.addVariableName(builder, resultVariableName)
    roomupdatefbs.RoomResult.addType(builder, roomupdatefbs.FactType.Text)
    roomupdatefbs.RoomResult.addValue(builder, resultValue)
    var room_result = roomupdatefbs.RoomResult.endRoomResult(builder)

    var results = roomupdatefbs.ResultSet.createResultsVector(builder, [room_result])

    roomupdatefbs.ResultSet.startResultSet(builder)
    roomupdatefbs.ResultSet.addResults(builder, results)
    var result_set = roomupdatefbs.ResultSet.endResultSet(builder)

    var roomResponseSource = builder.createString("1234")
    var roomResponseSubscriptionId = builder.createString("asdf")

    var result_sets = roomupdatefbs.RoomResponse.createResultSetsVector(builder, [result_set])

    roomupdatefbs.RoomResponse.startRoomResponse(builder)
    roomupdatefbs.RoomResponse.addSource(builder, roomResponseSource)
    roomupdatefbs.RoomResponse.addSubscriptionId(builder, roomResponseSubscriptionId)
    roomupdatefbs.RoomResponse.addResultSets(builder, result_sets)
    var full_updates_msg = roomupdatefbs.RoomResponse.endRoomResponse(builder)

    builder.finish(full_updates_msg)
    var msg_buf = builder.asUint8Array(); // Of type `Uint8Array`.
    return Buffer.from(msg_buf)
}

function testRoomUpdateDeserializationResult(data) {
    var buf = new flatbuffers.ByteBuffer(data);
    var room_response_obj = roomupdatefbs.RoomResponse.getRootAsRoomResponse(buf)
    console.log(room_response_obj.source())
    console.log(room_response_obj.subscriptionId())
    var result_sets_length = room_response_obj.resultSetsLength()
    console.log(result_sets_length)

    var result_set = room_response_obj.resultSets(0)
    var results_length = result_set.resultsLength()
    console.log(results_length)
    var result = result_set.results(0)
    console.log(result.variableName())
    console.log(result.type())
    console.log(uintToString(result.valueArray()))
}

function deserializeRoomUpdateMessage(data) {
    /*
    Return something like:
    {
        "source": ...
        "subscriptionId": ...
        "results": [{"x": 5, "y": 3.002, "z": "Hello"}, {"x": 3, "y": 0.0, "z": "Two"}]
    }
    */
    var buf = new flatbuffers.ByteBuffer(data);
    var room_response_obj = roomupdatefbs.RoomResponse.getRootAsRoomResponse(buf)
    let returnObj = {
        "source": room_response_obj.source(),
        "subscriptionId": room_response_obj.subscriptionId(),
        "results": new Array(room_response_obj.resultSetsLength())
    }
    for (let i = 0; i < returnObj.results.length; i += 1) {
        let returnObjResult = {};
        var result_set = room_response_obj.resultSets(i)
        for (let k = 0; k < result_set.resultsLength(); k += 1) {
            var result = result_set.results(k)
            // TODO: catch the variable to it's appropriate type in JS
            if (
                result.type() === roomupdatefbs.FactType.Integer ||
                result.type() === roomupdatefbs.FactType.Float
            ) {
                returnObjResult[result.variableName()] = +uintToString(result.valueArray())
            } else if (result.type() === roomupdatefbs.FactType.Binary) {
                returnObjResult[result.variableName()] = result.valueArray()
            } else {
                returnObjResult[result.variableName()] = uintToString(result.valueArray())
            }
        }
        returnObj.results[i] = returnObjResult;
    }
    return returnObj;
}

var s2Raw = testRoomUpdateSerializationResult()
var s2 = new Uint8Array(s2Raw)
// console.log(s2)
console.log(s2.join(' '))
console.log(s2.length)
console.log(Buffer.isBuffer(s2Raw))
testRoomUpdateDeserializationResult(s2)

/*
RoomUpdate
JS:
12 0 0 0 0 0 6 0 8 0 4 0 6 0 0 0 4 0 0 0 1 0 0 0 16 0 0 0 12 0 20 0 19 0 12 0 8 0 4 0 12 0 0 0 16 0 0 0 20 0 0 0 28 0 0 0 0 0 0 1 1 0 0 0 36 0 0 0 4 0 0 0 97 115 100 102 0 0 0 0 4 0 0 0 49 50 51 52 0 0 0 0 8 0 12 0 11 0 4 0 8 0 0 0 8 0 0 0 0 0 0 1 12 0 0 0 72 101 108 108 111 32 87 111 114 108 100 33
Golang:
12 0 0 0 0 0 6 0 8 0 4 0 6 0 0 0 4 0 0 0 1 0 0 0 16 0 0 0 12 0 20 0 19 0 12 0 8 0 4 0 12 0 0 0 16 0 0 0 20 0 0 0 28 0 0 0 0 0 0 1 1 0 0 0 36 0 0 0 4 0 0 0 97 115 100 102 0 0 0 0 4 0 0 0 49 50 51 52 0 0 0 0 8 0 12 0 11 0 4 0 8 0 0 0 8 0 0 0 0 0 0 1 12 0 0 0 72 101 108 108 111 32 87 111 114 108 100 33
Difference:
--------------------------------------------------------------------------------------------------------------------------------1---------------------------------------------------------------------------------------------------------------------1-----------------------------------------------------
*/

/*
RoomResult:
JS:
16 0 0 0 0 0 10 0 16 0 12 0 8 0 4 0 10 0 0 0 12 0 0 0 16 0 0 0 24 0 0 0 1 0 0 0 32 0 0 0 4 0 0 0 97 115 100 102 0 0 0 0 4 0 0 0 49 50 51 52 0 0 6 0 8 0 4 0 6 0 0 0 4 0 0 0 1 0 0 0 12 0 0 0 8 0 12 0 8 0 4 0 8 0 0 0 8 0 0 0 12 0 0 0 4 0 0 0 98 108 117 101 1 0 0 0 88 0 0 0
Golang:
16 0 0 0 0 0 10 0 16 0 12 0 8 0 4 0 10 0 0 0 12 0 0 0 16 0 0 0 24 0 0 0 1 0 0 0 32 0 0 0 4 0 0 0 97 115 100 102 0 0 0 0 4 0 0 0 49 50 51 52 0 0 6 0 8 0 4 0 6 0 0 0 4 0 0 0 1 0 0 0 12 0 0 0 8 0 12 0 8 0 4 0 8 0 0 0 8 0 0 0 12 0 0 0 4 0 0 0 98 108 117 101 1 0 0 0 88 0 0 0
Difference:
None
*/
